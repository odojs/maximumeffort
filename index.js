// Generated by CoffeeScript 1.9.2
var seuss,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

seuss = require('seuss-queue');

module.exports = function(url, maxWorkers) {
  var available, busy, count, create, drain, emit, pending, stop;
  if (maxWorkers == null) {
    maxWorkers = 16;
  }
  count = 0;
  available = seuss();
  pending = seuss();
  busy = {};
  create = function(id) {
    var internal;
    internal = new Worker(url);
    internal.addEventListener('message', function(e) {
      var cb, worker;
      worker = busy[id];
      delete busy[id];
      available.enqueue(worker);
      cb = worker.callback;
      cb(null, e.data);
      return drain();
    });
    return {
      id: id,
      internal: internal
    };
  };
  drain = function() {
    var task;
    if (pending.length() === 0) {
      return;
    }
    task = pending.dequeue();
    return emit(task.event, task.payload, task.callback);
  };
  stop = function(events) {
    var id, ref, ref1, results, task, tocheck, worker;
    for (id in busy) {
      worker = busy[id];
      if (ref = worker.event, indexOf.call(events, ref) >= 0) {
        delete busy[id];
        worker.internal.terminate();
        available.enqueue(create(id));
      }
    }
    tocheck = pending;
    pending = seuss();
    results = [];
    while (tocheck.length > 0) {
      task = tocheck.dequeue();
      if (ref1 = task.event, indexOf.call(events, ref1) >= 0) {
        continue;
      }
      results.push(pending.enqueue(task));
    }
    return results;
  };
  emit = function(e, p, cb) {
    var worker;
    if (available.length() > 0) {
      worker = available.dequeue();
      busy[worker.id] = worker;
      worker.event = e;
      worker.payload = p;
      worker.callback = cb;
      worker.internal.postMessage({
        id: worker.id,
        event: e,
        payload: p
      });
      return;
    }
    if (count < maxWorkers) {
      count++;
      available.enqueue(create(count));
      return emit(e, p, cb);
    }
    return pending.enqueue({
      event: e,
      payload: p,
      callback: cb
    });
  };
  return {
    emit: emit,
    stop: stop,
    info: function() {
      return {
        available: available.length(),
        pending: pending.length(),
        busy: Object.keys(busy).length
      };
    }
  };
};
